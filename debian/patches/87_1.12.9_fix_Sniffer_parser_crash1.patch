From 51e6114bc224953db555957a6c8c446eb3b1913d Mon Sep 17 00:00:00 2001
From: Guy Harris <guy@alum.mit.edu>
Date: Sun, 20 Dec 2015 15:18:37 -0800
Subject: [PATCH 87/90] Add bounds checks and fix a length argument.

Before reading the record header of a REC_FRAME{2,4,6} record, make sure
the record length is >= the length of that header.

Whe calling fix_pseudo_header(), pass the actual length of the packet
data, not the remaining length of the record (which may include
padding), so we don't read past the end of the packet data.

Bug: 11827
Change-Id: I1c63a4cb014c4616ffdd202660e68c576f266872
Reviewed-on: https://code.wireshark.org/review/12756
Reviewed-by: Guy Harris <guy@alum.mit.edu>
(cherry picked from commit 53a3e53fce30523d11ab3df319fba7b75d63076f)
Reviewed-on: https://code.wireshark.org/review/12758
(cherry picked from commit 3a3ddbd43eaa5ac3b90d938a641f02cd2266bdf4)
Reviewed-on: https://code.wireshark.org/review/13774
Reviewed-by: Balint Reczey <balint@balintreczey.hu>
---
 wiretap/ngsniffer.c | 49 ++++++++++++++++++++++++++++++++++---------------
 1 file changed, 34 insertions(+), 15 deletions(-)

diff --git a/wiretap/ngsniffer.c b/wiretap/ngsniffer.c
index 806381a..9c5370c 100644
--- a/wiretap/ngsniffer.c
+++ b/wiretap/ngsniffer.c
@@ -1171,7 +1171,7 @@ ngsniffer_process_record(wtap *wth, gboolean is_random, guint *padding,
 	gint64	bytes_read;
 	char	record_type[2];
 	char	record_length[4]; /* only 1st 2 bytes are length */
-	guint16	type, length;
+	guint	type, length;
 	struct frame2_rec frame2;
 	struct frame4_rec frame4;
 	struct frame6_rec frame6;
@@ -1218,6 +1218,13 @@ ngsniffer_process_record(wtap *wth, gboolean is_random, guint *padding,
 			return -1;
 		}
 
+		/* Do we have an f_frame2_struct worth of data? */
+		if (length < sizeof frame2) {
+			*err = WTAP_ERR_BAD_FILE;
+			*err_info = g_strdup("ngsniffer: REC_FRAME2 record length is less than record header length");
+			return -1;
+		}
+
 		/* Read the f_frame2_struct */
 		bytes_read = ng_file_read(&frame2, (unsigned int)sizeof frame2,
 		   wth, is_random, err, err_info);
@@ -1249,6 +1256,23 @@ ngsniffer_process_record(wtap *wth, gboolean is_random, guint *padding,
 			return -1;
 		}
 
+		/*
+		 * XXX - it looks as if some version 4 captures have
+		 * a bogus record length, based on the assumption
+		 * that the record is a frame2 record, i.e. the length
+		 * was calculated based on the record being a frame2
+		 * record, so it's too short by (sizeof frame4 - sizeof frame2).
+		 */
+		if (ngsniffer->maj_vers < 5 && ngsniffer->min_vers >= 95)
+			length += sizeof frame4 - sizeof frame2;
+
+		/* Do we have an f_frame4_struct worth of data? */
+		if (length < sizeof frame4) {
+			*err = WTAP_ERR_BAD_FILE;
+			*err_info = g_strdup("ngsniffer: REC_FRAME4 record length is less than record header length");
+			return -1;
+		}
+
 		/* Read the f_frame4_struct */
 		bytes_read = ng_file_read(&frame4, (unsigned int)sizeof frame4,
 		    wth, is_random, err, err_info);
@@ -1264,24 +1288,19 @@ ngsniffer_process_record(wtap *wth, gboolean is_random, guint *padding,
 		size = pletoh16(&frame4.size);
 		true_size = pletoh16(&frame4.true_size);
 
-		/*
-		 * XXX - it looks as if some version 4 captures have
-		 * a bogus record length, based on the assumption
-		 * that the record is a frame2 record.
-		 */
-		if (ngsniffer->maj_vers >= 5)
-			length -= sizeof frame4;	/* we already read that much */
-		else {
-			if (ngsniffer->min_vers >= 95)
-				length -= sizeof frame2;
-			else
-				length -= sizeof frame4;
-		}
+		length -= sizeof frame4;	/* we already read that much */
 
 		set_pseudo_header_frame4(&phdr->pseudo_header, &frame4);
 		break;
 
 	case REC_FRAME6:
+		/* Do we have an f_frame6_struct worth of data? */
+		if (length < sizeof frame6) {
+			*err = WTAP_ERR_BAD_FILE;
+			*err_info = g_strdup("ngsniffer: REC_FRAME6 record length is less than record header length");
+			return -1;
+		}
+
 		/* Read the f_frame6_struct */
 		bytes_read = ng_file_read(&frame6, (unsigned int)sizeof frame6,
 		    wth, is_random, err, err_info);
@@ -1365,7 +1384,7 @@ ngsniffer_process_record(wtap *wth, gboolean is_random, guint *padding,
 	}
 
 	phdr->pkt_encap = fix_pseudo_header(wth->file_encap,
-	    buf, length, &phdr->pseudo_header);
+	    buf, size, &phdr->pseudo_header);
 
 	/*
 	 * 40-bit time stamp, in units of timeunit picoseconds.
-- 
2.1.4

