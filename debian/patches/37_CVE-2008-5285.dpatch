#! /bin/sh /usr/share/dpatch/dpatch-run
## 37_CVE-2008-5285.dpatch by  <balint@balintreczey.hu>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Backport of security fix released in Wireshark 1.0.5

@DPATCH@
--- etch/epan/dissectors/packet-smtp.c.orig	2009-12-29 21:07:05.000000000 +0100
+++ etch/epan/dissectors/packet-smtp.c	2009-12-29 22:40:14.000000000 +0100
@@ -96,6 +96,7 @@
     gint                    length_remaining;
     gboolean                eom_seen = FALSE;
     gint                    next_offset;
+    gint                    loffset;
     gboolean                is_continuation_line;
     int                     cmdlen;
 
@@ -136,21 +137,6 @@
      * longer than what's in the buffer, so the "tvb_get_ptr()" call
      * won't throw an exception.
      */
-    linelen = tvb_find_line_end(tvb, offset, -1, &next_offset,
-      smtp_desegment && pinfo->can_desegment);
-    if (linelen == -1) {
-      /*
-       * We didn't find a line ending, and we're doing desegmentation;
-       * tell the TCP dissector where the data for this message starts
-       * in the data it handed us, and tell it we need one more byte
-       * (we may need more, but we'll try again if what we get next
-       * isn't enough), and return.
-       */
-      pinfo->desegment_offset = offset;
-      pinfo->desegment_len = 1;
-      return;
-    }
-    line = tvb_get_ptr(tvb, offset, linelen);
 
     frame_data = p_get_proto_data(pinfo->fd, proto_smtp);
 
@@ -182,6 +168,39 @@
 
       }
 
+      if(request) {
+	frame_data = se_alloc(sizeof(struct smtp_proto_data));
+
+	p_add_proto_data(pinfo->fd, proto_smtp, frame_data);	
+
+      }
+
+    loffset = offset;
+    while (tvb_offset_exists(tvb, loffset)) {
+
+    linelen = tvb_find_line_end(tvb, loffset, -1, &next_offset,
+      smtp_desegment && pinfo->can_desegment);
+    if (linelen == -1) {
+
+      if(offset == loffset) {
+      /*
+       * We didn't find a line ending, and we're doing desegmentation;
+       * tell the TCP dissector where the data for this message starts
+       * in the data it handed us, and tell it we need one more byte
+       * (we may need more, but we'll try again if what we get next
+       * isn't enough), and return.
+       */
+      pinfo->desegment_offset = loffset;
+      pinfo->desegment_len = 1;
+      return;
+      }
+      else {
+	linelen = tvb_length_remaining(tvb, loffset);
+	next_offset = loffset + linelen;
+      }
+    }
+    line = tvb_get_ptr(tvb, loffset, linelen);
+
       /*
        * Check whether or not this packet is an end of message packet
        * We should look for CRLF.CRLF and they may be split.
@@ -197,16 +216,16 @@
 	 * .CRLF at the begining of the same packet.
 	 */
 
-	if ((request_val->crlf_seen && tvb_strneql(tvb, offset, ".\r\n", 3) == 0) ||
-	    tvb_strneql(tvb, offset, "\r\n.\r\n", 5) == 0) {
+	if ((request_val->crlf_seen && tvb_strneql(tvb, loffset, ".\r\n", 3) == 0) ||
+	    tvb_strneql(tvb, loffset, "\r\n.\r\n", 5) == 0) {
 
 	  eom_seen = TRUE;
 
-	}
+	} 
 
-	length_remaining = tvb_length_remaining(tvb, offset);
-	if (length_remaining == tvb_reported_length_remaining(tvb, offset) &&
-	    tvb_strneql(tvb, offset + length_remaining - 2, "\r\n", 2) == 0) {
+	length_remaining = tvb_length_remaining(tvb, loffset);
+	if (length_remaining == tvb_reported_length_remaining(tvb, loffset) &&
+	    tvb_strneql(tvb, loffset + length_remaining - 2, "\r\n", 2) == 0) {
 
 	  request_val->crlf_seen = 1;
 
@@ -225,8 +244,6 @@
 
       if (request) {
 
-	frame_data = se_alloc(sizeof(struct smtp_proto_data));
-
 	if (request_val->reading_data) {
 	  /*
 	   * This is message data.
@@ -241,6 +258,9 @@
 	     */
 	    frame_data->pdu_type = SMTP_PDU_EOM;
 	    request_val->reading_data = FALSE;
+	    
+	    break;
+	    
 	  } else {
 	    /*
 	     * Message data with no EOM.
@@ -295,10 +315,14 @@
 	  }
 
 	}
+      }
 
-	p_add_proto_data(pinfo->fd, proto_smtp, frame_data);
+      /*
+       * Step past this line.
+       */
+      loffset = next_offset;
 
-      }
+    }
     }
 
     /*
@@ -310,6 +334,7 @@
       col_set_str(pinfo->cinfo, COL_PROTOCOL, "SMTP");
 
     if (check_col(pinfo->cinfo, COL_INFO)) {  /* Add the appropriate type here */
+      col_clear(pinfo->cinfo, COL_INFO);
 
       /*
        * If it is a request, we have to look things up, otherwise, just
@@ -328,14 +353,31 @@
 
 	case SMTP_PDU_EOM:
 
-	  col_add_fstr(pinfo->cinfo, COL_INFO, "EOM: %s",
-	      format_text(line, linelen));
+	  col_set_str(pinfo->cinfo, COL_INFO, "C: .");
+
 	  break;
 
 	case SMTP_PDU_CMD:
 
-	  col_add_fstr(pinfo->cinfo, COL_INFO, "Command: %s",
-	      format_text(line, linelen));
+	  loffset = offset;
+	  while (tvb_offset_exists(tvb, loffset)) {
+	    /*
+	     * Find the end of the line.
+	     */
+	    linelen = tvb_find_line_end(tvb, loffset, -1, &next_offset, FALSE);
+	    line = tvb_get_ptr(tvb, loffset, linelen);
+
+	    if(loffset == offset) 
+	      col_append_fstr(pinfo->cinfo, COL_INFO, "C: %s",
+			   format_text(line, linelen));
+	    else {
+	      col_append_fstr(pinfo->cinfo, COL_INFO, " | %s",
+			   format_text(line, linelen));
+	    }
+
+	    loffset = next_offset;
+
+	  }
 	  break;
 
 	}
@@ -343,9 +385,24 @@
       }
       else {
 
-	col_add_fstr(pinfo->cinfo, COL_INFO, "Response: %s",
-	    format_text(line, linelen));
+	  loffset = offset;
+	  while (tvb_offset_exists(tvb, loffset)) {
+	    /*
+	     * Find the end of the line.
+	     */
+	    linelen = tvb_find_line_end(tvb, loffset, -1, &next_offset, FALSE);
+	    line = tvb_get_ptr(tvb, loffset, linelen);
+
+	    if(loffset == offset) 
+	      col_append_fstr(pinfo->cinfo, COL_INFO, "S: %s",
+			   format_text(line, linelen));
+	    else {
+	      col_append_fstr(pinfo->cinfo, COL_INFO, " | %s",
+			   format_text(line, linelen));
+	    }
 
+	    loffset = next_offset;
+	  }
       }
     }
 
@@ -409,8 +466,7 @@
 	   * DATA command this terminates before sending another
 	   * request, but we should probably handle it.
 	   */
-	  proto_tree_add_text(smtp_tree, tvb, offset, linelen,
-	      "EOM: %s", format_text(line, linelen));
+	  proto_tree_add_text(smtp_tree, tvb, offset, linelen, "C: .");
 
 	  break;
 
@@ -424,6 +480,15 @@
 	   * previous command before sending another request, but we
 	   * should probably handle it.
 	   */
+
+	  loffset = offset;
+	while (tvb_offset_exists(tvb, loffset)) {
+
+	  /*
+	   * Find the end of the line.
+	   */
+	  linelen = tvb_find_line_end(tvb, loffset, -1, &next_offset, FALSE);
+
 	  if (linelen >= 4)
 	    cmdlen = 4;
 	  else
@@ -433,18 +498,24 @@
 	  /*
 	   * Put the command line into the protocol tree.
 	   */
-	  ti = proto_tree_add_text(smtp_tree, tvb, offset, next_offset - offset,
+	  ti = proto_tree_add_text(smtp_tree, tvb, loffset, next_offset - loffset,
 	        "Command: %s",
-		tvb_format_text(tvb, offset, next_offset - offset));
+		tvb_format_text(tvb, loffset, next_offset - loffset));
 	  cmdresp_tree = proto_item_add_subtree(ti, ett_smtp_cmdresp);
 
 	  proto_tree_add_item(cmdresp_tree, hf_smtp_req_command, tvb,
-			      offset, cmdlen, FALSE);
+			      loffset, cmdlen, FALSE);
 	  if (linelen > 5) {
 	    proto_tree_add_item(cmdresp_tree, hf_smtp_req_parameter, tvb,
-				offset + 5, linelen - 5, FALSE);
+				loffset + 5, linelen - 5, FALSE);
 	  }
 
+	  /*
+	   * Step past this line.
+	   */
+	  loffset = next_offset;
+
+	}
 	}
 
       }
@@ -506,8 +577,8 @@
 	  /*
 	   * If it's not a continuation line, quit.
 	   */
-	  if (!is_continuation_line)
-	    break;
+	  /* if (!is_continuation_line)
+	     break; */
 
 	}
 
