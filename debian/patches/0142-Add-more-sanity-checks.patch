From 36bce0d763e21000bbda5fec55def4cccf4df5aa Mon Sep 17 00:00:00 2001
From: Guy Harris <guy@alum.mit.edu>
Date: Thu, 2 Mar 2017 13:03:09 -0800
Subject: [PATCH 142/144] Add more sanity checks.

Conflicts:
	wiretap/k12.c

Bug: 13431
Change-Id: I330cb087c6e89277120057019cb5155f005ed269
Reviewed-on: https://code.wireshark.org/review/20337
Reviewed-by: Guy Harris <guy@alum.mit.edu>
(cherry picked from commit b019c5931c945c20b9bc3f0c1f904dd3bd590873)
Reviewed-on: https://code.wireshark.org/review/20339
Reviewed-on: https://code.wireshark.org/review/20524
Reviewed-by: Balint Reczey <balint@balintreczey.hu>
---
 wiretap/k12.c | 41 +++++++++++++++++++++++++++--------------
 1 file changed, 27 insertions(+), 14 deletions(-)

diff --git a/wiretap/k12.c b/wiretap/k12.c
index 1e8ad07..de16aa6 100644
--- a/wiretap/k12.c
+++ b/wiretap/k12.c
@@ -541,9 +541,9 @@ static gint get_record(k12_t *file_data, FILE_T fh, gint64 file_offset,
     return bytes_read;
 }
 
-static void
+static gboolean
 process_packet_data(struct wtap_pkthdr *phdr, Buffer *target, guint8 *buffer,
-                    gint len, k12_t *k12)
+                    guint record_len, k12_t *k12, int *err, gchar **err_info)
 {
     guint32 type;
     guint   buffer_offset;
@@ -553,6 +553,23 @@ process_packet_data(struct wtap_pkthdr *phdr, Buffer *target, guint8 *buffer,
     guint32 src_id;
     k12_src_desc_t* src_desc;
 
+    type = pntoh32(buffer + K12_RECORD_TYPE);
+    buffer_offset = (type == K12_REC_D0020) ? K12_PACKET_FRAME_D0020 : K12_PACKET_FRAME;
+    if (buffer_offset > record_len) {
+        *err = WTAP_ERR_BAD_FILE;
+        *err_info = g_strdup_printf("k12: Frame data offset %u > record length %u",
+                                    buffer_offset, record_len);
+        return FALSE;
+    }
+
+    length = pntoh32(buffer + K12_RECORD_FRAME_LEN) & 0x00001FFF;
+    if (length > record_len - buffer_offset) {
+        *err = WTAP_ERR_BAD_FILE;
+        *err_info = g_strdup_printf("k12: Frame length %u > record frame data %u",
+                                    length, record_len - buffer_offset);
+        return FALSE;
+    }
+
     phdr->rec_type = REC_TYPE_PACKET;
     phdr->presence_flags = WTAP_HAS_TS;
 
@@ -561,17 +578,13 @@ process_packet_data(struct wtap_pkthdr *phdr, Buffer *target, guint8 *buffer,
     phdr->ts.secs = (guint32) ((ts / 2000000) + 631152000);
     phdr->ts.nsecs = (guint32) ( (ts % 2000000) * 500 );
 
-    length = pntoh32(buffer + K12_RECORD_FRAME_LEN) & 0x00001FFF;
     phdr->len = phdr->caplen = length;
 
-    type = pntoh32(buffer + K12_RECORD_TYPE);
-    buffer_offset = (type == K12_REC_D0020) ? K12_PACKET_FRAME_D0020 : K12_PACKET_FRAME;
-
     buffer_assure_space(target, length);
     memcpy(buffer_start_ptr(target), buffer + buffer_offset, length);
 
     /* extra information need by some protocols */
-    extra_len = len - buffer_offset - length;
+    extra_len = record_len - buffer_offset - length;
     buffer_assure_space(&(k12->extra_info), extra_len);
     memcpy(buffer_start_ptr(&(k12->extra_info)),
            buffer + buffer_offset + length, extra_len);
@@ -601,7 +614,7 @@ process_packet_data(struct wtap_pkthdr *phdr, Buffer *target, guint8 *buffer,
 
         switch(src_desc->input_type) {
             case K12_PORT_ATMPVC:
-                if ((long)(buffer_offset + length + K12_PACKET_OFFSET_CID) < len) {
+                if ((long)(buffer_offset + length + K12_PACKET_OFFSET_CID) < record_len) {
                     phdr->pseudo_header.k12.input_info.atm.vp =  pntoh16(buffer + buffer_offset + length + K12_PACKET_OFFSET_VP);
                     phdr->pseudo_header.k12.input_info.atm.vc =  pntoh16(buffer + buffer_offset + length + K12_PACKET_OFFSET_VC);
                     phdr->pseudo_header.k12.input_info.atm.cid =  *((unsigned char*)(buffer + buffer_offset + length + K12_PACKET_OFFSET_CID));
@@ -622,6 +635,7 @@ process_packet_data(struct wtap_pkthdr *phdr, Buffer *target, guint8 *buffer,
 
     phdr->pseudo_header.k12.input = src_id;
     phdr->pseudo_header.k12.stuff = k12;
+    return TRUE;
 }
 
 static gboolean k12_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset) {
@@ -653,7 +667,7 @@ static gboolean k12_read(wtap *wth, int *err, gchar **err_info, gint64 *data_off
         } else if (len < K12_RECORD_SRC_ID + 4) {
             /* Record not large enough to contain a src ID */
             *err = WTAP_ERR_BAD_FILE;
-            *err_info = g_strdup_printf("data record length %d too short", len);
+            *err_info = g_strdup_printf("k12: Data record length %d too short", len);
             return FALSE;
         }
 
@@ -680,9 +694,7 @@ static gboolean k12_read(wtap *wth, int *err, gchar **err_info, gint64 *data_off
 
     } while ( ((type & K12_MASK_PACKET) != K12_REC_PACKET && (type & K12_MASK_PACKET) != K12_REC_D0020) || !src_id || !src_desc );
 
-    process_packet_data(&wth->phdr, wth->frame_buffer, buffer, len, k12);
-
-    return TRUE;
+    return process_packet_data(&wth->phdr, wth->frame_buffer, buffer, (guint)len, k12, err, err_info);
 }
 
 
@@ -690,6 +702,7 @@ static gboolean k12_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *ph
     k12_t *k12 = (k12_t *)wth->priv;
     guint8* buffer;
     gint len;
+    gboolean status;
 
     K12_DBG(5,("k12_seek_read: ENTER"));
 
@@ -711,11 +724,11 @@ static gboolean k12_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *ph
 
     buffer = k12->rand_read_buff;
 
-    process_packet_data(phdr, buf, buffer, len, k12);
+    status = process_packet_data(phdr, buf, buffer, (guint)len, k12, err, err_info);
 
     K12_DBG(5,("k12_seek_read: DONE OK"));
 
-    return TRUE;
+    return status;
 }
 
 
-- 
2.1.4

