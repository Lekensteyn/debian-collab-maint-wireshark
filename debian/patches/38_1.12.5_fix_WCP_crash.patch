From 7d1323de1fb2b94e9e74e98ce0d845e8e841d46d Mon Sep 17 00:00:00 2001
From: Evan Huus <eapache@gmail.com>
Date: Sat, 21 Mar 2015 13:19:25 -0400
Subject: [PATCH 08/10] wcp: add validations to decompressed_entry

Ensure that a reference to past bytes refers to bytes that actually exist.

Bug: 10978
Change-Id: I2fe8f0a9493cc237803bb761876f83b4511cfbf6
Conflicts:
	epan/dissectors/packet-wcp.c
Reviewed-on: https://code.wireshark.org/review/7800
Reviewed-by: Evan Huus <eapache@gmail.com>
(cherry picked from commit 65db3786b52c5f2cf4059d53816b09d4c845588c)
Reviewed-on: https://code.wireshark.org/review/8636
Reviewed-by: Balint Reczey <balint@balintreczey.hu>
---
 epan/dissectors/packet-wcp.c | 33 +++++++++++++++++++++++++++++++--
 1 file changed, 31 insertions(+), 2 deletions(-)

diff --git a/epan/dissectors/packet-wcp.c b/epan/dissectors/packet-wcp.c
index f496e3c..8a65102 100644
--- a/epan/dissectors/packet-wcp.c
+++ b/epan/dissectors/packet-wcp.c
@@ -121,6 +121,8 @@ typedef struct {
 
 	guint8  *buf_cur;
 	guint8  buffer[MAX_WIN_BUF_LEN];
+	/* # initialized bytes in the buffer (since buf_cur may wrap around) */
+	guint16 initialized;
 
 }wcp_window_t;
 
@@ -174,6 +176,8 @@ static gint ett_wcp_field = -1;
 
 static expert_field ei_wcp_compressed_data_exceeds = EI_INIT;
 static expert_field ei_wcp_uncompressed_data_exceeds = EI_INIT;
+static expert_field ei_wcp_invalid_window_offset = EI_INIT;
+static expert_field ei_wcp_invalid_match_length = EI_INIT;
 
 static dissector_handle_t fr_uncompressed_handle;
 
@@ -400,9 +404,13 @@ static void dissect_wcp( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
 
 static guint8 *
 decompressed_entry(guint8 *dst, guint16 data_offset,
-    guint16 data_cnt, int *len, guint8 * buf_start, guint8 *buf_end)
+    guint16 data_cnt, int *len, wcp_window_t *buf_ptr)
 {
 	const guint8 *src;
+	guint8 *buf_start, *buf_end;
+
+	buf_start = buf_ptr->buffer;
+	buf_end = buf_ptr->buffer + MAX_WIN_BUF_LEN;
 
 /* do the decompression for one field */
 
@@ -415,6 +423,8 @@ decompressed_entry(guint8 *dst, guint16 data_offset,
 
 	while( data_cnt--){
 		*dst = *src;
+		if ( buf_ptr->initialized < MAX_WIN_BUF_LEN)
+			buf_ptr->initialized++;
 		if ( ++(*len) >MAX_WCP_BUF_LEN){
 			return NULL;	/* end of buffer error */
 		}
@@ -448,7 +458,9 @@ wcp_window_t *get_wcp_window_ptr( packet_info *pinfo){
 	if ( !wcp_circuit_data){
 		wcp_circuit_data = wmem_new(wmem_file_scope(), wcp_circuit_data_t);
 		wcp_circuit_data->recv.buf_cur = wcp_circuit_data->recv.buffer;
+		wcp_circuit_data->recv.initialized = 0;
 		wcp_circuit_data->send.buf_cur = wcp_circuit_data->send.buffer;
+		wcp_circuit_data->send.initialized = 0;
 		circuit_add_proto_data(circuit, proto_wcp, wcp_circuit_data);
 	}
 	if (pinfo->pseudo_header->x25.flags & FROM_DCE)
@@ -566,10 +578,23 @@ static tvbuff_t *wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pin
 					src += 2;
 					offset += 2;
 				}
+				if (data_offset + 1 > buf_ptr->initialized) {
+					expert_add_info_format(pinfo, cd_item, &ei_wcp_invalid_window_offset,
+							"Data offset exceeds valid window size (%d > %d)",
+							data_offset+1, buf_ptr->initialized);
+					return NULL;
+				}
+
+				if (data_offset + 1 < data_cnt) {
+					expert_add_info_format(pinfo, cd_item, &ei_wcp_invalid_window_offset,
+							"Data count exceeds offset (%d > %d)",
+							data_cnt, data_offset+1);
+					return NULL;
+				}
 				if ( !pinfo->fd->flags.visited){	/* if first pass */
 					dst = decompressed_entry(dst,
 					    data_offset, data_cnt, &len,
-					    buf_start, buf_end);
+					    buf_ptr);
 					if (dst == NULL){
 						expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,
 							"Uncompressed data exceeds maximum buffer length (%d > %d)",
@@ -600,6 +625,8 @@ static tvbuff_t *wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pin
 					*dst = *src;
 					if ( dst++ == buf_end)
 						dst = buf_start;
+					if (buf_ptr->initialized < MAX_WIN_BUF_LEN)
+						buf_ptr->initialized++;
 				}
 				++src;
 				++offset;
@@ -753,6 +780,8 @@ proto_register_wcp(void)
     static ei_register_info ei[] = {
         { &ei_wcp_compressed_data_exceeds, { "wcp.compressed_data.exceeds", PI_MALFORMED, PI_ERROR, "Compressed data exceeds maximum buffer length", EXPFILL }},
         { &ei_wcp_uncompressed_data_exceeds, { "wcp.uncompressed_data.exceeds", PI_MALFORMED, PI_ERROR, "Uncompressed data exceeds maximum buffer length", EXPFILL }},
+        { &ei_wcp_invalid_window_offset, { "wcp.off.invalid", PI_MALFORMED, PI_ERROR, "Offset points outside of visible window", EXPFILL }},
+        { &ei_wcp_invalid_match_length, { "wcp.len.invalid", PI_MALFORMED, PI_ERROR, "Length greater than offset", EXPFILL }},
     };
 
     expert_module_t* expert_wcp;
-- 
2.1.4

