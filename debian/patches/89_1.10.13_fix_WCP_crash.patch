From f69d9d2a59477cd1d2f3747b57abce1b29a6a40c Mon Sep 17 00:00:00 2001
From: Guy Harris <guy@alum.mit.edu>
Date: Mon, 12 Jan 2015 20:07:09 -0800
Subject: [PATCH 3/3] Do bounds checking when decompressing WCP packets.

Extract the data offset and count only once, and make sure we don't run
past the end of the data we've copied from the packet; have
decompressed_entry() just do the decompression, rather than also
fetching the data offset and count.

Add some comments while we're at it.

I have basically copied the new code except for the whitespaces
instead of just back-porting the changes because the changes were
an almost full rewrite already.

Bug: 10844
Change-Id: I2dc2f9594422ffa8f15fd5c57c9dac2e30e363f4
Reviewed-on: https://code.wireshark.org/review/6514
Reviewed-by: Guy Harris <guy@alum.mit.edu>
(cherry picked from commit b204ff4846fe84b7789893c6b1d9afbdecac5b5d)
Reviewed-on: https://code.wireshark.org/review/6515
Reviewed-on: https://code.wireshark.org/review/7712
Reviewed-by: Balint Reczey <balint@balintreczey.hu>
Tested-by: Balint Reczey <balint@balintreczey.hu>
---
 epan/dissectors/packet-wcp.c | 185 ++++++++++++++++++++++++++++---------------
 1 file changed, 120 insertions(+), 65 deletions(-)

diff --git a/epan/dissectors/packet-wcp.c b/epan/dissectors/packet-wcp.c
index 46534e0..39c9889 100644
--- a/epan/dissectors/packet-wcp.c
+++ b/epan/dissectors/packet-wcp.c
@@ -105,15 +105,20 @@
 #include <string.h>
 #include <epan/packet.h>
 #include "packet-frame.h"
+#include <epan/pint.h>
 #include <epan/circuit.h>
 #include <epan/emem.h>
 #include <epan/etypes.h>
 #include <epan/nlpid.h>
+#include <epan/exceptions.h>
 
 #define MAX_WIN_BUF_LEN 0x7fff		/* storage size for decompressed data */
-#define MAX_WCP_BUF_LEN 2048		/* storage size for decompressed data */
+#define MAX_WCP_BUF_LEN 2048		/* storage size for compressed data */
 #define FROM_DCE	0x80		/* for direction setting */
 
+void proto_register_wcp(void);
+void proto_reg_handoff_wcp(void);
+
 typedef struct {
 
 	guint8  *buf_cur;
@@ -156,6 +161,7 @@ static int hf_wcp_hist_size = -1;
 static int hf_wcp_ppc = -1;
 static int hf_wcp_pib = -1;
 
+static int hf_wcp_compressed_data = -1;
 static int hf_wcp_comp_bits = -1;
 static int hf_wcp_comp_marker = -1;
 static int hf_wcp_short_len = -1;
@@ -165,6 +171,7 @@ static int hf_wcp_long_run = -1;
 static int hf_wcp_offset = -1;
 
 static gint ett_wcp = -1;
+static gint ett_wcp_comp_data = -1;
 static gint ett_wcp_field = -1;
 
 static dissector_handle_t fr_uncompressed_handle;
@@ -394,26 +401,14 @@ static void dissect_wcp( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
 }
 
 
-static guint8 *decompressed_entry( guint8 *src, guint8 *dst, int *len, guint8 * buf_start, guint8 *buf_end){
+static guint8 *
+decompressed_entry(guint8 *dst, guint16 data_offset,
+    guint16 data_cnt, int *len, guint8 * buf_start, guint8 *buf_end)
+{
+	const guint8 *src;
 
 /* do the decompression for one field */
 
-	guint16 data_offset, data_cnt;
-	guint8 tmp = *src;
-
-	data_offset = (*(src++) & 0xf) << 8;	/* get high byte */
-	data_offset += *(src++);		/* add next byte */
-
-	if (( tmp & 0xf0) == 0x10){		/* 2 byte count */
-		data_cnt = *src;
-		data_cnt++;
-
-	}else {					/* one byte count */
-		data_cnt = tmp >> 4;
-		data_cnt++;
-	}
-
-
 	src = (dst - 1 - data_offset);
 	if ( src < buf_start)
 		src += MAX_WIN_BUF_LEN;
@@ -472,24 +467,27 @@ static tvbuff_t *wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pin
 
 /* do the packet data uncompression and load it into the dst buffer */
 
-	proto_tree	*sub_tree;
-	proto_item	*ti;
+	proto_tree	*cd_tree, *sub_tree;
+	proto_item	*cd_item, *ti;
 
-	int len=0, i = -1;
+	int len, i;
 	int cnt = tvb_reported_length( src_tvb)-1;	/* don't include check byte */
 
 	guint8 *dst, *src, *buf_start, *buf_end, comp_flag_bits = 0;
+	guint16 data_offset, data_cnt;
 	guint8 src_buf[ MAX_WCP_BUF_LEN];
-	tvbuff_t *volatile tvb = 0;
+	tvbuff_t *tvb;
 	wcp_window_t *buf_ptr = 0;
-	wcp_pdata_t *volatile pdata_ptr;
-	volatile gboolean bounds_error = FALSE;
+	wcp_pdata_t *pdata_ptr;
 
 	buf_ptr = get_wcp_window_ptr( pinfo);
 
 	buf_start = buf_ptr->buffer;
 	buf_end = buf_start + MAX_WIN_BUF_LEN;
 
+	cd_item = proto_tree_add_item(tree, hf_wcp_compressed_data,
+	    src_tvb, offset, cnt - offset, ENC_NA);
+	cd_tree = proto_item_add_subtree(cd_item, ett_wcp_comp_data);
 	if (cnt - offset > MAX_WCP_BUF_LEN) {
 		if (tree)
 			proto_tree_add_text( tree, src_tvb, offset, -1,
@@ -498,66 +496,129 @@ static tvbuff_t *wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pin
 		return NULL;
 	}
 
-	src = tvb_memcpy(src_tvb, src_buf, offset, cnt - offset);
+	/*
+	 * XXX - this will thow an exception if a snapshot length cut short
+	 * the data.  We may want to try to dissect the data in that case,
+	 * and we may even want to try to decompress it, *but* we will
+	 * want to mark the buffer of decompressed data as incomplete, so
+	 * that we don't try to use it for decompressing later packets.
+	 */
+	src = (guint8 *)tvb_memcpy(src_tvb, src_buf, offset, cnt - offset);
 	dst = buf_ptr->buf_cur;
+	len = 0;
+	i = -1;
 
-	while( offset++ < cnt){
-
+	while( offset < cnt){
+		/* There are i bytes left for this byte of flag bits */
 		if ( --i >= 0){
-			if ( comp_flag_bits & 0x80){	/* if this is a compressed entry */
-
-				if ( !pinfo->fd->flags.visited){	/* if first pass */
-					dst = decompressed_entry( src, dst, &len, buf_start, buf_end);
+			/*
+			 * There's still at least one more byte left for
+			 * the current set of compression flag bits; is
+			 * it compressed data or uncompressed data?
+			 */
+			if ( comp_flag_bits & 0x80){
+				/* This byte is compressed data */
+				if (!(offset + 1 < cnt)) {
+					/*
+					 * The data offset runs past the
+					 * end of the data.
+					 */
+					THROW(ReportedBoundsError);
 				}
+				data_offset = pntohs(src) & WCP_OFFSET_MASK;
 				if ((*src & 0xf0) == 0x10){
+					/*
+					 * The count of bytes to copy from
+					 * the dictionary window is in the
+					 * byte following the data offset.
+					 */
+					if (!(offset + 2 < cnt)) {
+						/*
+						 * The data count runs past the
+						 * end of the data.
+						 */
+						THROW(ReportedBoundsError);
+				}
+					data_cnt = *(src + 2) + 1;
 					if ( tree) {
-						ti = proto_tree_add_item( tree, hf_wcp_long_run, src_tvb,
-							 offset-1, 3, ENC_NA);
+						ti = proto_tree_add_item( cd_tree, hf_wcp_long_run, src_tvb,
+							 offset, 3, ENC_NA);
 						sub_tree = proto_item_add_subtree(ti, ett_wcp_field);
 						proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,
-							 offset-1, 2, pntohs(src));
+							 offset, 2, data_offset);
 
 						proto_tree_add_item( sub_tree, hf_wcp_long_len, src_tvb,
-							 offset+1, 1, ENC_BIG_ENDIAN);
+							 offset+2, 1, ENC_BIG_ENDIAN);
 					}
 					src += 3;
-					offset += 2;
+					offset += 3;
 				}else{
+					/*
+					 * The count of bytes to copy from
+					 * the dictionary window is in
+					 * the upper 4 bits of the next
+					 * byte.
+					 */
+					data_cnt = (*src >> 4) + 1;
 					if ( tree) {
-						ti = proto_tree_add_item( tree, hf_wcp_short_run, src_tvb,
-							 offset - 1, 2, ENC_NA);
+						ti = proto_tree_add_item( cd_tree, hf_wcp_short_run, src_tvb,
+							 offset, 2, ENC_NA);
 						sub_tree = proto_item_add_subtree(ti, ett_wcp_field);
 						proto_tree_add_uint( sub_tree, hf_wcp_short_len, src_tvb,
-							 offset-1, 1, *src);
+							 offset, 1, *src);
 						proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,
-							 offset-1, 2, pntohs(src));
+							 offset, 2, data_offset);
 					}
 					src += 2;
-					offset += 1;
+					offset += 2;
 				}
-			}else {
 				if ( !pinfo->fd->flags.visited){	/* if first pass */
+					dst = decompressed_entry(dst,
+					    data_offset, data_cnt, &len,
+					    buf_start, buf_end);
+					if (dst == NULL){
+						return NULL;
+					}
+				}
+			}else {
+				/*
+				 * This byte is uncompressed data; is there
+				 * room for it in the buffer of uncompressed
+				 * data?
+				 */
+				if ( ++len >MAX_WCP_BUF_LEN){
+					/* No - report an error. */
+					return NULL;
+				}
+
+				if ( !pinfo->fd->flags.visited){
+					/*
+					 * This is the first pass through
+					 * the packets, so copy it to the
+					 * buffer of unco,pressed data.
+					 */
 					*dst = *src;
 					if ( dst++ == buf_end)
 						dst = buf_start;
 				}
 				++src;
-				++len;
-
-			}
-
-			if ( len >MAX_WCP_BUF_LEN){
-				return NULL;
+				++offset;
 			}
 
+			/* Skip to the next compression flag bit */
 			comp_flag_bits <<= 1;
 
-		}else {	/* compressed data flag */
-
+		}else {
+			/*
+			 * There are no more bytes left for the current
+			 * set of compression flag bits, so this byte
+			 * is another byte of compression flag bits.
+			 */
 			comp_flag_bits = *src++;
-			if (tree)
-				proto_tree_add_uint( tree, hf_wcp_comp_bits,  src_tvb, offset-1, 1,
+			if (cd_tree)
+				proto_tree_add_uint(cd_tree, hf_wcp_comp_bits,  src_tvb, offset, 1,
 					comp_flag_bits);
+			offset++;
 
 			i = 8;
 		}
@@ -567,8 +628,10 @@ static tvbuff_t *wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pin
 					/* get uncompressed data */
 		pdata_ptr = p_get_proto_data( pinfo->fd, proto_wcp);
 
-		if ( !pdata_ptr)	/* exit if no data */
+		if ( !pdata_ptr) {	/* exit if no data */
+			REPORT_DISSECTOR_BUG("Can't find uncompressed data");
 			return NULL;
+		}
 		len = pdata_ptr->len;
 	} else {
 
@@ -582,19 +645,7 @@ static tvbuff_t *wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pin
 		buf_ptr->buf_cur = dst;
 	}
 
-
-        TRY {
                 tvb = tvb_new_child_real_data(src_tvb,  pdata_ptr->buffer, pdata_ptr->len, pdata_ptr->len);
-        }
-        CATCH(BoundsError) {
-		DISSECTOR_ASSERT_NOT_REACHED();
-        }
-        CATCH(ReportedBoundsError) {
-		bounds_error = TRUE;
-        }
-        ENDTRY;
-
-	if (bounds_error) return NULL;
 
 	/* Add new data to the data source list */
 	add_new_data_source( pinfo, tvb, "Uncompressed WCP");
@@ -661,6 +712,9 @@ proto_register_wcp(void)
 	{ &hf_wcp_pib,
 	  { "PIB", "wcp.pib", FT_UINT8, BASE_DEC, NULL, 0,
 	  	NULL, HFILL }},
+	{ &hf_wcp_compressed_data,
+	  { "Compressed Data", "wcp.compressed_data", FT_NONE, BASE_NONE, NULL, 0,
+	    "Raw compressed data", HFILL }},
 	{ &hf_wcp_comp_bits,
 	  { "Compress Flag", "wcp.flag", FT_UINT8, BASE_HEX, NULL, 0,
 	  	"Compressed byte flag", HFILL }},
@@ -688,6 +742,7 @@ proto_register_wcp(void)
 
     static gint *ett[] = {
         &ett_wcp,
+        &ett_wcp_comp_data,
 	&ett_wcp_field,
     };
 
-- 
2.1.4

