From 666beef78f8c3fc6b7faf3510e0dbfcd5f2ddfd2 Mon Sep 17 00:00:00 2001
From: Guy Harris <guy@alum.mit.edu>
Date: Tue, 12 May 2015 10:32:29 -0700
Subject: [PATCH 03/10] Backport some parts of
 Ia5dba2a6f81151e87b614461349d611cffc16210.

This should make sure logcat_open() doesn't report an error for a file
that's not a logcat file, preventing other heuristic open routines from
checking the file.

Change-Id: I4c042459550f6d27f40a76f103d95a7f4e317969
Reviewed-on: https://code.wireshark.org/review/8432
Reviewed-by: Guy Harris <guy@alum.mit.edu>
Conflicts: wiretap/logcat.c
Reviewed-on: https://code.wireshark.org/review/8644
Reviewed-by: Balint Reczey <balint@balintreczey.hu>
---
 wiretap/logcat.c | 113 ++++++++++++++++++++++++++++++++++++-------------------
 1 file changed, 74 insertions(+), 39 deletions(-)

diff --git a/wiretap/logcat.c b/wiretap/logcat.c
index 78f10aa..e8340ec 100644
--- a/wiretap/logcat.c
+++ b/wiretap/logcat.c
@@ -130,7 +130,15 @@ static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,
 
 }
 
-static gint detect_version(wtap *wth, int *err, gchar **err_info)
+/*
+ * Returns:
+ *
+ *  -2 if we get an EOF at the beginning;
+ *  -1 on an I/O error;
+ *  0 if the record doesn't appear to be valid;
+ *  1-{max gint} as a version number if we got a valid record.
+ */
+static gint detect_version(FILE_T fh, int *err, gchar **err_info)
 {
     gint                     bytes_read;
     guint16                  payload_length;
@@ -146,33 +154,41 @@ static gint detect_version(wtap *wth, int *err, gchar **err_info)
     guint16                  msg_len;
 
     /* 16-bit payload length */
-    bytes_read = file_read(&tmp, 2, wth->fh);
+    bytes_read = file_read(&tmp, 2, fh);
     if (bytes_read != 2) {
-        *err = file_error(wth->fh, err_info);
-        if (*err == 0 && bytes_read != 0)
+        *err = file_error(fh, err_info);
+        if (*err == 0) {
+            if (bytes_read == 0) {
+                /*
+                 * Got an EOF at the beginning.
+                 */
+                return -2;
+            }
             *err = WTAP_ERR_SHORT_READ;
+            return 0;
+        }
         return -1;
     }
     payload_length = pletoh16(&tmp);
 
+    /* must contain at least priority and two nulls as separator */
+    if (payload_length < 3)
+        return 0;
+    /* payload length may not exceed the maximum payload size */
+    if (payload_length > LOGGER_ENTRY_MAX_PAYLOAD)
+        return 0;
+
     /* 16-bit header length (or padding, equal to 0x0000) */
-    bytes_read = file_read(&tmp, 2, wth->fh);
+    bytes_read = file_read(&tmp, 2, fh);
     if (bytes_read != 2) {
-        *err = file_error(wth->fh, err_info);
-        if (*err == 0 && bytes_read != 0)
-            *err = WTAP_ERR_SHORT_READ;
-        return -1;
+        *err = file_error(fh, err_info);
+        if (*err != 0)
+            return -1;
+        return 0;
     }
     hdr_size = pletoh16(&tmp);
     read_sofar = 4;
 
-    /* must contain at least priority and two nulls as separator */
-    if (payload_length < 3)
-        return -1;
-    /* payload length may not exceed the maximum payload size */
-    if (payload_length > LOGGER_ENTRY_MAX_PAYLOAD)
-        return -1;
-
     /* ensure buffer is large enough for all versions */
     buffer = (guint8 *) g_malloc(sizeof(*log_entry_v2) + payload_length);
     log_entry_v2 = (struct logger_entry_v2 *) buffer;
@@ -193,16 +209,15 @@ static gint detect_version(wtap *wth, int *err, gchar **err_info)
         }
 
         bytes_read = file_read(buffer + read_sofar, entry_len - read_sofar,
-                wth->fh);
+                fh);
         if (bytes_read != entry_len - read_sofar) {
-            *err = file_error(wth->fh, err_info);
-            if (*err == 0 && bytes_read != 0)
-                *err = WTAP_ERR_SHORT_READ;
-            /* short read, end of file? Whatever, this cannot be valid. */
-            version = -1;
-            break;
+            *err = file_error(fh, err_info);
+            g_free(buffer);
+            if (*err != 0)
+                return -1;
+            return 0;
         }
-        read_sofar += bytes_read;
+        read_sofar += entry_len - read_sofar;
 
         /* A v2 msg has a 32-bit userid instead of v1 priority */
         if (get_priority(msg_payload[0]) == '?')
@@ -225,8 +240,9 @@ static gint detect_version(wtap *wth, int *err, gchar **err_info)
         return version;
     }
 
+    /* No version number is valid */
     g_free(buffer);
-    return -1;
+    return 0;
 }
 
 static gboolean logcat_read_packet(struct logcat_phdr *logcat, FILE_T fh,
@@ -311,27 +327,46 @@ static gboolean logcat_seek_read(wtap *wth, gint64 seek_off,
 
 int logcat_open(wtap *wth, int *err, gchar **err_info _U_)
 {
-    int                 local_err;
-    gchar              *local_err_info;
     gint                version;
     gint                tmp_version;
     struct logcat_phdr *logcat;
 
     /* check first 3 packets (or 2 or 1 if EOF) versions to check file format is correct */
-    version = detect_version(wth, &local_err, &local_err_info);
-    if (version <= 0)
-        return 0;
-
-    tmp_version = detect_version(wth, &local_err, &local_err_info);
-    if (tmp_version < 0 && !file_eof(wth->fh)) {
-        return 0;
-    } else if (tmp_version > 0) {
-        if (tmp_version != version)
+    version = detect_version(wth->fh, err, err_info); /* first packet */
+    if (version == -1)
+        return -1; /* I/O error */
+    if (version == 0)
+        return 0;  /* not a logcat file */
+    if (version == -2)
+        return 0;  /* empty file, so not any type of file */
+
+    tmp_version = detect_version(wth->fh, err, err_info); /* second packet */
+    if (tmp_version == -1)
+        return -1; /* I/O error */
+    if (tmp_version == 0)
+        return 0;  /* not a logcat file */
+    if (tmp_version != -2) {
+        /* we've read two packets; do they have the same version? */
+        if (tmp_version != version) {
+            /* no, so this is presumably not a logcat file */
             return 0;
+        }
 
-        tmp_version = detect_version(wth, &local_err, &local_err_info);
-        if (tmp_version != version && !file_eof(wth->fh))
-            return 0;
+        tmp_version = detect_version(wth->fh, err, err_info); /* third packet */
+        if (tmp_version < 0)
+            return -1; /* I/O error */
+        if (tmp_version == 0)
+            return 0;  /* not a logcat file */
+        if (tmp_version != -2) {
+            /*
+             * we've read three packets and the first two have the same
+             * version; does the third have the same version?
+             */
+            if (tmp_version != version) {
+                /* no, so this is presumably not a logcat file */
+                return 0;
+            }
+        }
     }
 
     if (file_seek(wth->fh, 0, SEEK_SET, err) == -1)
-- 
2.1.4

