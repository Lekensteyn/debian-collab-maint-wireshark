From f83b56a4dc2d32aa5129c228de195be6a44d9da8 Mon Sep 17 00:00:00 2001
From: AndersBroman <anders.broman@ericsson.com>
Date: Fri, 31 Oct 2014 15:13:36 +0100
Subject: [PATCH 1/2] Clean up handling of BDC coded numbers a bit.

[Back-ported to 1.12 to fix the fuzz failure reported in bug 11201.]

Bug: 11201
Change-Id: Ic3d523664e3c78b4ed289b7e5acf3f53614c6d54
Reviewed-on: https://code.wireshark.org/review/5027
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit d93be95fc0e7011e8b4ade9171e7e66146063296)
Conflicts:
	epan/dissectors/packet-gsm_a_dtap.c
Reviewed-on: https://code.wireshark.org/review/8730
Petri-Dish: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 9fa6881060b46b6ea1a3c89529f6ebebc1caf77f)
Reviewed-on: https://code.wireshark.org/review/9045
Reviewed-by: Balint Reczey <balint@balintreczey.hu>
---
 epan/dissectors/packet-gsm_a_dtap.c | 220 ++++++++++++++++--------------------
 1 file changed, 98 insertions(+), 122 deletions(-)

diff --git a/epan/dissectors/packet-gsm_a_dtap.c b/epan/dissectors/packet-gsm_a_dtap.c
index 41da64d..8a959fc 100644
--- a/epan/dissectors/packet-gsm_a_dtap.c
+++ b/epan/dissectors/packet-gsm_a_dtap.c
@@ -1063,76 +1063,59 @@ de_day_saving_time(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guin
 static guint16
 de_emerg_num_list(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len _U_, gchar *add_string _U_, int string_len _U_)
 {
-	guint32     curr_offset;
-	guint8      en_len, oct, i;
-	guint8      count;
-	guint8     *poctets;
-	proto_tree *subtree;
-	proto_item *item;
-	gboolean    malformed_number;
-
-	curr_offset = offset;
-
-	count = 1;
-	while ((curr_offset - offset) < len){
-		/* Length of 1st Emergency Number information note 1) octet 3
-		 * NOTE 1: The length contains the number of octets used to encode the
-		 * Emergency Service Category Value and the Number digits.
-		 */
-		en_len = tvb_get_guint8(tvb, curr_offset);
-
-		item = proto_tree_add_uint(tree, hf_gsm_a_dtap_emergency_number_information,
-			tvb, curr_offset, en_len + 1, count);
-		subtree = proto_item_add_subtree(item, ett_gsm_dtap_elem[DE_EMERGENCY_NUM_LIST]);
-		proto_tree_add_item(subtree, hf_gsm_a_dtap_emerg_num_info_length, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
-
-		curr_offset++;
-		/* 0 0 0 Emergency Service Category Value (see
-		 *       Table 10.5.135d/3GPP TS 24.008
-		 * Table 10.5.135d/3GPP TS 24.008: Service Category information element
-		 */
-		proto_tree_add_bits_item(subtree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 3, ENC_BIG_ENDIAN);
-		proto_tree_add_item(subtree, hf_gsm_a_dtap_serv_cat_b5, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
-		proto_tree_add_item(subtree, hf_gsm_a_dtap_serv_cat_b4, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
-		proto_tree_add_item(subtree, hf_gsm_a_dtap_serv_cat_b3, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
-		proto_tree_add_item(subtree, hf_gsm_a_dtap_serv_cat_b2, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
-		proto_tree_add_item(subtree, hf_gsm_a_dtap_serv_cat_b1, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
-		curr_offset++;
-		en_len--;
-
-		poctets = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, curr_offset, en_len);
-
-		my_dgt_tbcd_unpack(a_bigbuf, poctets, en_len, &Dgt_mbcd);
-
-		item = proto_tree_add_string_format(subtree, hf_gsm_a_dtap_emergency_bcd_num,
-			tvb, curr_offset, en_len,
-			a_bigbuf,
-			"BCD Digits: %s",
-			a_bigbuf);
-
-		malformed_number = FALSE;
-		for(i = 0; i < en_len - 1; i++)
-		{
-			oct = poctets[i];
-			if (((oct & 0xf0) == 0xf0) || ((oct & 0x0f) == 0x0f))
-			{
-				malformed_number = TRUE;
-				break;
-			}
-		}
-
-		oct = poctets[en_len - 1];
-		if ((oct & 0x0f) == 0x0f)
-			malformed_number = TRUE;
-
-		if(malformed_number)
-			expert_add_info(pinfo, item, &ei_gsm_a_dtap_end_mark_unexpected);
-
-		curr_offset = curr_offset + en_len;
-		count++;
-	}
+    guint32     curr_offset;
+    guint8      en_len;
+    guint8      count;
+    proto_tree *subtree;
+    proto_item *item;
+    const char *digit_str;
+
+    curr_offset = offset;
+
+    count = 1;
+    while ((curr_offset - offset) < len) {
+        /* Length of 1st Emergency Number information note 1) octet 3
+         * NOTE 1: The length contains the number of octets used to encode the
+         * Emergency Service Category Value and the Number digits.
+         */
+        en_len = tvb_get_guint8(tvb, curr_offset);
+
+        item = proto_tree_add_uint(tree, hf_gsm_a_dtap_emergency_number_information,
+            tvb, curr_offset, en_len + 1, count);
+        subtree = proto_item_add_subtree(item, ett_gsm_dtap_elem[DE_EMERGENCY_NUM_LIST]);
+        proto_tree_add_item(subtree, hf_gsm_a_dtap_emerg_num_info_length, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
+
+        curr_offset++;
+        /* 0 0 0 Emergency Service Category Value (see
+         *       Table 10.5.135d/3GPP TS 24.008
+         * Table 10.5.135d/3GPP TS 24.008: Service Category information element
+         */
+        proto_tree_add_bits_item(subtree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 3, ENC_BIG_ENDIAN);
+        proto_tree_add_item(subtree, hf_gsm_a_dtap_serv_cat_b5, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
+        proto_tree_add_item(subtree, hf_gsm_a_dtap_serv_cat_b4, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
+        proto_tree_add_item(subtree, hf_gsm_a_dtap_serv_cat_b3, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
+        proto_tree_add_item(subtree, hf_gsm_a_dtap_serv_cat_b2, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
+        proto_tree_add_item(subtree, hf_gsm_a_dtap_serv_cat_b1, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
+        curr_offset++;
+        en_len--;
+
+        digit_str = tvb_bcd_dig_to_wmem_packet_str(tvb, curr_offset, en_len, NULL, FALSE);
+        item = proto_tree_add_string(subtree, hf_gsm_a_dtap_emergency_bcd_num, tvb, curr_offset, en_len, digit_str);
+
+        /* Check for overdicadic digits, we used the standard digit map from tvbuff.c
+		 *  0   1   2   3   4   5   6   7   8   9   a   b   c   d   e  f
+		 * '0','1','2','3','4','5','6','7','8','9','?','?','?','?','?','?'
+         *
+         */
+        if(strchr(digit_str,'?')){
+            expert_add_info(pinfo, item, &ei_gsm_a_dtap_end_mark_unexpected);
+        }
+
+        curr_offset = curr_offset + en_len;
+        count++;
+    }
 
-	return(len);
+    return (len);
 }
 
 /*
@@ -2177,64 +2160,57 @@ const value_string gsm_a_dtap_screening_ind_values[] = {
 static guint16
 de_bcd_num(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, int header_field, gboolean *address_extracted)
 {
-	guint8     *poctets;
-	guint8      extension, oct;
-	guint32     curr_offset, i, num_string_len;
-	proto_item *item;
-	gboolean    malformed_number;
-
-	*address_extracted = FALSE;
-	curr_offset = offset;
-
-	extension = tvb_get_guint8(tvb, curr_offset) & 0x80;
-	proto_tree_add_item(tree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
-	proto_tree_add_item(tree, hf_gsm_a_dtap_type_of_number, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
-	proto_tree_add_item(tree, hf_gsm_a_dtap_numbering_plan_id, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
-	curr_offset++;
-
-	if (!extension)
-	{
-		proto_tree_add_item(tree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
-		proto_tree_add_item(tree, hf_gsm_a_dtap_present_ind, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
-		proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+3, 3, ENC_BIG_ENDIAN);
-		proto_tree_add_item(tree, hf_gsm_a_dtap_screening_ind, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
-		curr_offset++;
-	}
+    guint8     *poctets;
+    guint8      extension;
+    guint32     curr_offset, num_string_len;
+    proto_item *item;
+    const char *digit_str;
 
-	NO_MORE_DATA_CHECK(len);
-
-	num_string_len = len - (curr_offset - offset);
-	poctets = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, curr_offset, num_string_len);
+    *address_extracted = FALSE;
+    curr_offset = offset;
 
-	*address_extracted = TRUE;
-	my_dgt_tbcd_unpack(a_bigbuf, poctets, num_string_len,
-		&Dgt_mbcd);
+    extension = tvb_get_guint8(tvb, curr_offset) & 0x80;
+    proto_tree_add_item(tree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
+    proto_tree_add_item(tree, hf_gsm_a_dtap_type_of_number, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
+    proto_tree_add_item(tree, hf_gsm_a_dtap_numbering_plan_id, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
+    curr_offset++;
 
-	item = proto_tree_add_string_format(tree, header_field,
-		tvb, curr_offset, num_string_len,
-		a_bigbuf,
-		"BCD Digits: %s",
-		a_bigbuf);
-
-	malformed_number = FALSE;
-	for(i = 0; i < num_string_len - 1; i++)
-	{
-		oct = poctets[i];
-		if (((oct & 0xf0) == 0xf0) || ((oct & 0x0f) == 0x0f))
-		{
-			malformed_number = TRUE;
-			break;
-		}
-	}
-
-	oct = poctets[num_string_len - 1];
-	if ((oct & 0x0f) == 0x0f)
-		malformed_number = TRUE;
+    if (!extension)
+    {
+        proto_tree_add_item(tree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
+        proto_tree_add_item(tree, hf_gsm_a_dtap_present_ind, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
+        proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+3, 3, ENC_BIG_ENDIAN);
+        proto_tree_add_item(tree, hf_gsm_a_dtap_screening_ind, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
+        curr_offset++;
+    }
 
-	if(malformed_number)
-		expert_add_info(pinfo, item, &ei_gsm_a_dtap_end_mark_unexpected);
+    NO_MORE_DATA_CHECK(len);
+
+    num_string_len = len - (curr_offset - offset);
+    poctets = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, curr_offset, num_string_len);
+
+    *address_extracted = TRUE;
+    my_dgt_tbcd_unpack(a_bigbuf, poctets, num_string_len,
+        &Dgt_mbcd);
+
+    digit_str = tvb_bcd_dig_to_wmem_packet_str(tvb, curr_offset, num_string_len, NULL, FALSE);
+    item = proto_tree_add_string(tree, header_field, tvb, curr_offset, num_string_len, digit_str);
+    item = proto_tree_add_string_format(tree, header_field,
+        tvb, curr_offset, num_string_len,
+        a_bigbuf,
+        "BCD Digits: %s",
+        a_bigbuf);
+
+    /* Check for overdicadic digits, we used the standard digit map from tvbuff.c
+		*  0   1   2   3   4   5   6   7   8   9   a   b   c   d   e  f
+		* '0','1','2','3','4','5','6','7','8','9','?','?','?','?','?','?'
+        *
+        */
+    if(strchr(digit_str,'?')){
+        expert_add_info(pinfo, item, &ei_gsm_a_dtap_end_mark_unexpected);
+    }
 
-	return(len);
+    return (len);
 }
 
 /*
-- 
2.1.4

