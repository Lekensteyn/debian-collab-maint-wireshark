From 7b7fa64f53bc89ebdfc88fe3966a2b7f2e0532f1 Mon Sep 17 00:00:00 2001
From: Anders Broman <anders.broman@ericsson.com>
Date: Thu, 8 Nov 2012 12:52:08 +0000
Subject: [PATCH 3/8] Create cr once when drawing the graphs

svn path=/trunk/; revision=45969

Conflicts:
	ui/gtk/io_stat.c
---
 ui/gtk/io_stat.c |  378 ++++++++++++++++++++++++++----------------------------
 1 file changed, 179 insertions(+), 199 deletions(-)

diff --git a/ui/gtk/io_stat.c b/ui/gtk/io_stat.c
index 0942c58..96da597 100644
--- a/ui/gtk/io_stat.c
+++ b/ui/gtk/io_stat.c
@@ -1055,213 +1055,193 @@ io_stat_draw(io_stat_t *io)
 #else
 			cr = gdk_cairo_create (io->pixmap);
 #endif
-			cairo_move_to (cr, x_pos, io->surface_height-bottom_y_border+15);
-			pango_cairo_show_layout (cr, layout);
-			cairo_destroy (cr);
-			cr = NULL;
-		}
-
-	}
-	g_object_unref(G_OBJECT(layout));
 
-	/*
-	 * Loop over all graphs and draw them
-	 */
-	for(i=MAX_GRAPHS-1; i>=0; i--){
-		guint64 val;
-		guint32 interval, x_pos, y_pos, prev_x_pos, prev_y_pos;
-		/* Moving average variables */
-		guint32 mavg_in_average_count = 0, mavg_left = 0, mavg_right = 0;
-		guint64 mavg_cumulated = 0;
-		guint64 mavg_to_remove = 0, mavg_to_add = 0;
+            cairo_move_to (cr, x_pos, io->surface_height-bottom_y_border+15);
+            pango_cairo_show_layout (cr, layout);
+            cairo_destroy (cr);
+            cr = NULL;
+        }
 
-		if(!io->graphs[i].display){
-			continue;
-		}
-
-		if(io->filter_type == MOVING_AVERAGE_FILTER){
-			/* "Warm-up phase" - calculate average on some data not displayed;
-			   just to make sure average on leftmost and rightmost displayed
-			   values is as reliable as possible
-			*/
-			guint64 warmup_interval;
-
-			if(first_interval/io->interval > io->filter_order/2){
-				warmup_interval = first_interval/io->interval - io->filter_order/2;
-				warmup_interval *= io->interval;
-			} else {
-				warmup_interval = 0;
-			}
-			mavg_to_remove = warmup_interval;
-			for(;warmup_interval<first_interval;warmup_interval+=io->interval){
-				mavg_cumulated += get_it_value(io, i, (int)warmup_interval/io->interval);
-				mavg_in_average_count++;
-				mavg_left++;
-			}
-			mavg_cumulated += get_it_value(io, i, (int)warmup_interval/io->interval);
-			mavg_in_average_count++;
-			for(warmup_interval += io->interval;
-			    ((warmup_interval < (first_interval + (io->filter_order/2) * (guint64)io->interval)) &&
-			    (warmup_interval <= (io->num_items * (guint64)io->interval)));
-			    warmup_interval += io->interval) {
-
-				mavg_cumulated += get_it_value(io, i, (int)warmup_interval / io->interval);
-				mavg_in_average_count++;
-				mavg_right++;
-			}
-			mavg_to_add = warmup_interval;
-		}
-
-		/* initialize prev x/y to the value of the first interval */
-		prev_x_pos = draw_width-1 -
-			     io->pixels_per_tick * ((last_interval - first_interval) / io->interval) +
-			     io->left_x_border;
-		val = get_it_value(io, i, first_interval / io->interval);
-
-		if(io->filter_type==MOVING_AVERAGE_FILTER
-		&& mavg_in_average_count > 0) {
-		    val = mavg_cumulated / mavg_in_average_count;
-		}
-
-		if(val>max_y){
-			prev_y_pos=0;
-		} else if (io->max_y_units==LOGARITHMIC_YSCALE){
-			if (val==0) {
-				prev_y_pos = (guint32)(draw_height - 1 + top_y_border);
-			} else {
-				prev_y_pos = (guint32) (
-							(draw_height - ystart)-1 -
-							((log10((double)((gint64)val)) * (draw_height - ystart)) / log10((double)max_y)) +
-							top_y_border
-						       );
-			}
-		} else {
-			prev_y_pos=(guint32)(draw_height-1-(val*draw_height)/max_y+top_y_border);
-		}
-
-		for(interval = first_interval;
-			interval < last_interval;
-			interval += io->interval) {
-			x_pos=draw_width-1-io->pixels_per_tick*((last_interval-interval)/io->interval)+io->left_x_border;
-
-			val = get_it_value(io, i, interval/io->interval);
-			/* Moving average calculation */
-			if (io->filter_type==MOVING_AVERAGE_FILTER) {
-				if (interval != first_interval){
-					mavg_left++;
-					if (mavg_left > io->filter_order/2) {
-						mavg_left--;
-						mavg_in_average_count--;
-						mavg_cumulated -= get_it_value(io, i, (int)mavg_to_remove/io->interval);
-						mavg_to_remove += io->interval;
-					}
-					if (mavg_to_add<=(guint64)io->num_items*io->interval){
-						mavg_in_average_count++;
-						mavg_cumulated += get_it_value(io, i, (int)mavg_to_add/io->interval);
-						mavg_to_add += io->interval;
-					} else {
-						mavg_right--;
-					}
-				}
-				if (mavg_in_average_count > 0) {
-					val = mavg_cumulated / mavg_in_average_count;
-				}
-			}
-
-			if (val>max_y) {
-				y_pos=0;
-			} else if (io->max_y_units==LOGARITHMIC_YSCALE) {
-				if (val==0) {
-					y_pos=(guint32)(draw_height-1+top_y_border);
-				} else {
-					y_pos = (guint32) (
-							   (draw_height - ystart) - 1 -
-							   (log10((double)(gint64)val) * (draw_height - ystart)) / log10((double)max_y) +
-							   top_y_border
-							  );
-				}
-			} else {
-				y_pos = (guint32)(draw_height - 1 -
-						  ((val * draw_height) / max_y) +
-						  top_y_border);
-			}
+    }
+    g_object_unref(G_OBJECT(layout));
 
-			switch(io->graphs[i].plot_style){
-			case PLOT_STYLE_LINE:
-				/* Dont draw anything if the segment entirely above the top of the graph
-				 */
-				if( (prev_y_pos!=0) || (y_pos!=0) ){
+    /*
+    * Loop over all graphs and draw them
+    */
 #if GTK_CHECK_VERSION(2,22,0)
-					cr = cairo_create (io->surface);
+    cr = cairo_create (io->surface);
 #else
-					cr = gdk_cairo_create (io->pixmap);
+    cr = gdk_cairo_create (io->pixmap);
 #endif
-					gdk_cairo_set_source_color (cr, &io->graphs[i].color);
-					cairo_set_line_width (cr, 1.0);
-					cairo_move_to(cr, prev_x_pos+0.5, prev_y_pos+0.5);
-					cairo_line_to(cr, x_pos+0.5, y_pos+0.5);
-					cairo_stroke(cr);
-					cairo_destroy(cr);
-				}
-				break;
-			case PLOT_STYLE_IMPULSE:
-				if(val){
-#if GTK_CHECK_VERSION(2,22,0)
-					cr = cairo_create (io->surface);
-#else
-					cr = gdk_cairo_create (io->pixmap);
-#endif
-					gdk_cairo_set_source_color (cr, &io->graphs[i].color);
-					cairo_set_line_width (cr, 1.0);
-					cairo_move_to(cr, x_pos+0.5, draw_height-1+top_y_border+0.5);
-					cairo_line_to(cr, x_pos+0.5, y_pos+0.5);
-					cairo_stroke(cr);
-					cairo_destroy(cr);
-				}
-				break;
-			case PLOT_STYLE_FILLED_BAR:
-				if(val){
-#if GTK_CHECK_VERSION(2,22,0)
-					cr = cairo_create (io->surface);
-#else
-					cr = gdk_cairo_create (io->pixmap);
-#endif
-					cairo_rectangle (cr,
-						x_pos-(gdouble)io->pixels_per_tick/2+0.5,
-						y_pos+0.5,
-						io->pixels_per_tick,
-						draw_height-1+top_y_border-y_pos);
-					gdk_cairo_set_source_color (cr, &io->graphs[i].color);
-					cairo_fill (cr);
-					cairo_destroy (cr);
-				}
-				break;
-			case PLOT_STYLE_DOT:
-				if(val){
-#if GTK_CHECK_VERSION(2,22,0)
-					cr = cairo_create (io->surface);
-#else
-					cr = gdk_cairo_create (io->pixmap);
-#endif
-					cairo_arc (cr,
-						x_pos+0.5,
-						y_pos+0.5,
-						(gdouble)io->pixels_per_tick/2,
-						0,
-						2 * G_PI);
-					gdk_cairo_set_source_color (cr, &io->graphs[i].color);
-					cairo_fill (cr);
-					cairo_destroy (cr);
-				}
-				break;
-			}
+    gdk_cairo_set_source_color (cr, &io->graphs[i].color);
+    cairo_set_line_width (cr, 1.0);
 
-			prev_y_pos=y_pos;
-			prev_x_pos=x_pos;
-		}
-	}
+	for(i=MAX_GRAPHS-1; i>=0; i--){
+        guint64 val;
+        guint32 interval, x_pos, y_pos, prev_x_pos, prev_y_pos;
+        /* Moving average variables */
+        guint32 mavg_in_average_count = 0, mavg_left = 0, mavg_right = 0;
+        guint64 mavg_cumulated = 0;
+        guint64 mavg_to_remove = 0, mavg_to_add = 0;
+
+        if(!io->graphs[i].display){
+            continue;
+        }
+
+        if(io->filter_type == MOVING_AVERAGE_FILTER){
+            /* "Warm-up phase" - calculate average on some data not displayed;
+            just to make sure average on leftmost and rightmost displayed
+            values is as reliable as possible
+            */
+            guint64 warmup_interval;
+
+            if(first_interval/io->interval > io->filter_order/2){
+                warmup_interval = first_interval/io->interval - io->filter_order/2;
+                warmup_interval *= io->interval;
+            } else {
+                warmup_interval = 0;
+            }
+            mavg_to_remove = warmup_interval;
+            for(;warmup_interval<first_interval;warmup_interval+=io->interval){
+                mavg_cumulated += get_it_value(io, i, (int)warmup_interval/io->interval);
+                mavg_in_average_count++;
+                mavg_left++;
+            }
+            mavg_cumulated += get_it_value(io, i, (int)warmup_interval/io->interval);
+            mavg_in_average_count++;
+            for(warmup_interval += io->interval;
+                ((warmup_interval < (first_interval + (io->filter_order/2) * (guint64)io->interval)) &&
+                (warmup_interval <= (io->num_items * (guint64)io->interval)));
+            warmup_interval += io->interval) {
+
+                mavg_cumulated += get_it_value(io, i, (int)warmup_interval / io->interval);
+                mavg_in_average_count++;
+                mavg_right++;
+            }
+            mavg_to_add = warmup_interval;
+        }
+
+        /* initialize prev x/y to the value of the first interval */
+        prev_x_pos = draw_width-1 -
+            io->pixels_per_tick * ((last_interval - first_interval) / io->interval) +
+            io->left_x_border;
+        val = get_it_value(io, i, first_interval / io->interval);
+
+        if(io->filter_type==MOVING_AVERAGE_FILTER
+            && mavg_in_average_count > 0) {
+                val = mavg_cumulated / mavg_in_average_count;
+        }
+
+        if(val>max_y){
+            prev_y_pos=0;
+        } else if (io->max_y_units==LOGARITHMIC_YSCALE){
+            if (val==0) {
+                prev_y_pos = (guint32)(draw_height - 1 + top_y_border);
+            } else {
+                prev_y_pos = (guint32) (
+                    (draw_height - ystart)-1 -
+                    ((log10((double)((gint64)val)) * (draw_height - ystart)) / log10((double)max_y)) +
+                    top_y_border
+                    );
+            }
+        } else {
+            prev_y_pos=(guint32)(draw_height-1-(val*draw_height)/max_y+top_y_border);
+        }
+
+        for(interval = first_interval;
+            interval < last_interval;
+            interval += io->interval) {
+                x_pos=draw_width-1-io->pixels_per_tick*((last_interval-interval)/io->interval)+io->left_x_border;
+
+                val = get_it_value(io, i, interval/io->interval);
+                /* Moving average calculation */
+                if (io->filter_type==MOVING_AVERAGE_FILTER) {
+                    if (interval != first_interval){
+                        mavg_left++;
+                        if (mavg_left > io->filter_order/2) {
+                            mavg_left--;
+                            mavg_in_average_count--;
+                            mavg_cumulated -= get_it_value(io, i, (int)mavg_to_remove/io->interval);
+                            mavg_to_remove += io->interval;
+                        }
+                        if (mavg_to_add<=(guint64)io->num_items*io->interval){
+                            mavg_in_average_count++;
+                            mavg_cumulated += get_it_value(io, i, (int)mavg_to_add/io->interval);
+                            mavg_to_add += io->interval;
+                        } else {
+                            mavg_right--;
+                        }
+                    }
+                    if (mavg_in_average_count > 0) {
+                        val = mavg_cumulated / mavg_in_average_count;
+                    }
+                }
+
+                if (val>max_y) {
+                    y_pos=0;
+                } else if (io->max_y_units==LOGARITHMIC_YSCALE) {
+                    if (val==0) {
+                        y_pos=(guint32)(draw_height-1+top_y_border);
+                    } else {
+                        y_pos = (guint32) (
+                            (draw_height - ystart) - 1 -
+                            (log10((double)(gint64)val) * (draw_height - ystart)) / log10((double)max_y) +
+                            top_y_border
+                            );
+                    }
+                } else {
+                    y_pos = (guint32)(draw_height - 1 -
+                        ((val * draw_height) / max_y) +
+                        top_y_border);
+                }
+
+                switch(io->graphs[i].plot_style){
+                case PLOT_STYLE_LINE:
+                    /* Dont draw anything if the segment entirely above the top of the graph
+                    */
+                    if( (prev_y_pos!=0) || (y_pos!=0) ){
+                        cairo_move_to(cr, prev_x_pos+0.5, prev_y_pos+0.5);
+                        cairo_line_to(cr, x_pos+0.5, y_pos+0.5);
+                        cairo_stroke(cr);
+                    }
+                    break;
+                case PLOT_STYLE_IMPULSE:
+                    if(val){
+                        cairo_move_to(cr, x_pos+0.5, draw_height-1+top_y_border+0.5);
+                        cairo_line_to(cr, x_pos+0.5, y_pos+0.5);
+                        cairo_stroke(cr);
+                    }
+                    break;
+                case PLOT_STYLE_FILLED_BAR:
+                    if(val){
+                        cairo_rectangle (cr,
+                            x_pos-(gdouble)io->pixels_per_tick/2+0.5,
+                            y_pos+0.5,
+                            io->pixels_per_tick,
+                            draw_height-1+top_y_border-y_pos);
+                        cairo_fill (cr);
+                    }
+                    break;
+                case PLOT_STYLE_DOT:
+                    if(val){
+                        cairo_arc (cr,
+                            x_pos+0.5,
+                            y_pos+0.5,
+                            (gdouble)io->pixels_per_tick/2,
+                            0,
+                            2 * G_PI);
+                        cairo_fill (cr);
+                    }
+                    break;
+                }
+
+                prev_y_pos=y_pos;
+                prev_x_pos=x_pos;
+        }
+    }
+	cairo_destroy (cr);
 
-	cr = gdk_cairo_create (gtk_widget_get_window(io->draw_area));
+    cr = gdk_cairo_create (gtk_widget_get_window(io->draw_area));
 
 #if GTK_CHECK_VERSION(2,22,0)
 	cairo_set_source_surface (cr, io->surface, 0, 0);
-- 
1.7.10.4

