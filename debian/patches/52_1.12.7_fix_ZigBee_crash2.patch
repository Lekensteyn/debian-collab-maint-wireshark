From 1f21835ea605c68089e7066cf2956c166a2abbfc Mon Sep 17 00:00:00 2001
From: Guy Harris <guy@alum.mit.edu>
Date: Sun, 9 Aug 2015 23:55:55 -0700
Subject: [PATCH 07/12] Use the reported length where appropriate.

Use the captured length to know how much data to decrypt.  Use the
reported length to determine whether we have a null payload and to se
the reported length of the decrypted payload and of tvbuffs for the
un-decrypted payload.

Bug: 11389
Change-Id: I8670a5eb5f5a7df134c09ddb3c9dfd611ffa839e
Reviewed-on: https://code.wireshark.org/review/9956
Reviewed-by: Guy Harris <guy@alum.mit.edu>
(cherry picked from commit 76d50a7f46df6cd74c38f664e778d8563e4cab68)
Reviewed-on: https://code.wireshark.org/review/10616
Reviewed-by: Balint Reczey <balint@balintreczey.hu>
---
 epan/dissectors/packet-zbee-security.c | 26 +++++++++++++++-----------
 1 file changed, 15 insertions(+), 11 deletions(-)

diff --git a/epan/dissectors/packet-zbee-security.c b/epan/dissectors/packet-zbee-security.c
index 7f9bc79..02f1b5e 100644
--- a/epan/dissectors/packet-zbee-security.c
+++ b/epan/dissectors/packet-zbee-security.c
@@ -429,10 +429,11 @@ dissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint o
 
     zbee_security_packet    packet;
     guint           mic_len;
-    gint            payload_len;
+    gint            payload_reported_len;
     tvbuff_t       *payload_tvb;
 
 #ifdef HAVE_LIBGCRYPT
+    gint               payload_captured_len;
     guint8             *enc_buffer;
     guint8             *dec_buffer;
     gboolean            decrypted;
@@ -603,8 +604,8 @@ dissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint o
     }
 
     /* Check for null payload. */
-    payload_len = tvb_captured_length_remaining(tvb, offset+mic_len);
-    if (payload_len == 0)
+    payload_reported_len = tvb_reported_length_remaining(tvb, offset+mic_len);
+    if (payload_reported_len == 0)
         return NULL;
 
     /**********************************************
@@ -617,12 +618,15 @@ dissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint o
         (packet.level == ZBEE_SEC_MIC128)) {
 
         /* Payload is only integrity protected. Just return the sub-tvbuff. */
-        return tvb_new_subset(tvb, offset, payload_len, payload_len);
+        return tvb_new_subset_length(tvb, offset, payload_reported_len);
     }
 
 #ifdef HAVE_LIBGCRYPT
+    /* How much payload was actually captured? */
+    payload_captured_len = tvb_captured_length_remaining(tvb, offset+mic_len);
+
     /* Allocate memory to decrypt the payload into. */
-    dec_buffer = (guint8 *)g_malloc(payload_len);
+    dec_buffer = (guint8 *)g_malloc(payload_captured_len);
 
     decrypted = FALSE;
     if ( packet.src64 ) {
@@ -633,14 +637,14 @@ dissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint o
                     case ZBEE_SEC_KEY_NWK:
                         if ( (key_rec = nwk_hints->nwk) ) {
                             decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,
-                                payload_len, mic_len, nwk_hints->nwk->key);
+                                payload_captured_len, mic_len, nwk_hints->nwk->key);
                         }
                         break;
 
                     default:
                         if ( (key_rec = nwk_hints->link) ) {
                             decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,
-                                payload_len, mic_len, nwk_hints->link->key);
+                                payload_captured_len, mic_len, nwk_hints->link->key);
                         }
                         break;
                 }
@@ -662,7 +666,7 @@ dissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint o
                     GSList_i = *nwk_keyring;
                     while ( GSList_i && !decrypted ) {
                         decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,
-                                payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);
+                                payload_captured_len, mic_len, ((key_record_t *)(GSList_i->data))->key);
 
                         if (decrypted) {
                             /* save pointer to the successful key record */
@@ -685,7 +689,7 @@ dissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint o
                 GSList_i = zbee_pc_keyring;
                 while ( GSList_i && !decrypted ) {
                     decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,
-                            payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);
+                            payload_captured_len, mic_len, ((key_record_t *)(GSList_i->data))->key);
 
                     if (decrypted) {
                         /* save pointer to the successful key record */
@@ -718,7 +722,7 @@ dissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint o
         }
 
         /* Found a key that worked, setup the new tvbuff_t and return */
-        payload_tvb = tvb_new_child_real_data(tvb, dec_buffer, payload_len, payload_len);
+        payload_tvb = tvb_new_child_real_data(tvb, dec_buffer, payload_captured_len, payload_reported_len);
         tvb_set_free_cb(payload_tvb, g_free); /* set up callback to free dec_buffer */
         add_new_data_source(pinfo, payload_tvb, "Decrypted ZigBee Payload");
 
@@ -732,7 +736,7 @@ dissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint o
     /* Add expert info. */
     expert_add_info(pinfo, sec_tree, &ei_zbee_sec_encrypted_payload);
     /* Create a buffer for the undecrypted payload. */
-    payload_tvb = tvb_new_subset(tvb, offset, payload_len, -1);
+    payload_tvb = tvb_new_subset_length(tvb, offset, payload_reported_len);
     /* Dump the payload to the data dissector. */
     call_dissector(data_handle, payload_tvb, pinfo, tree);
     /* Couldn't decrypt, so return NULL. */
-- 
2.1.4

