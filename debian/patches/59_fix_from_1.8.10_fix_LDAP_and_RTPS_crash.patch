From 138dc2cd33ee3cfc08dcc207052f50b14971cc4a Mon Sep 17 00:00:00 2001
From: Evan Huus <eapache@gmail.com>
Date: Sun, 1 Sep 2013 12:57:43 +0000
Subject: [PATCH 3/4] Copy over revisions from the trunk:

  ------------------------------------------------------------------------
  r51213 | eapache | 2013-08-08 06:50:11 -0400 (Thu, 08 Aug 2013) | 4 lines

  Correctly check bounds on dim_max.

  Fixes https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=9019

  ------------------------------------------------------------------------
  r51516 | eapache | 2013-08-25 13:31:15 -0400 (Sun, 25 Aug 2013) | 4 lines

  Make sure our ldap_call_response_t struct is always completely initialized,
  fixing a "Conditional jump or move depends on uninitialised value" error found
  by valgrind fuzzing.

  ------------------------------------------------------------------------

svn path=/trunk-1.8/; revision=51624
---
 asn1/ldap/packet-ldap-template.c |    4 +++-
 epan/dissectors/packet-ldap.c    |   12 +++++++-----
 epan/dissectors/packet-rtps.c    |    5 +++++
 epan/dissectors/packet-rtps2.c   |    5 +++++
 4 files changed, 20 insertions(+), 6 deletions(-)

diff --git a/asn1/ldap/packet-ldap-template.c b/asn1/ldap/packet-ldap-template.c
index a57c923..b64ff2b 100644
--- a/asn1/ldap/packet-ldap-template.c
+++ b/asn1/ldap/packet-ldap-template.c
@@ -778,6 +778,8 @@ ldap_match_call_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gu
           lcr.req_frame=0;
           lcr.rep_frame=pinfo->fd->num;
           break;
+        default:
+          return NULL;
       }
       lcrp=(ldap_call_response_t *)g_hash_table_lookup(ldap_info->matched, &lcr);
 
@@ -811,7 +813,7 @@ ldap_match_call_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gu
         }
         /* if we cant reuse the old one, grab a new chunk */
         if(!lcrp){
-          lcrp=se_new(ldap_call_response_t);
+          lcrp=se_new0(ldap_call_response_t);
         }
         lcrp->messageId=messageId;
         lcrp->req_frame=pinfo->fd->num;
diff --git a/epan/dissectors/packet-ldap.c b/epan/dissectors/packet-ldap.c
index 33867f3..c8d56ff 100644
--- a/epan/dissectors/packet-ldap.c
+++ b/epan/dissectors/packet-ldap.c
@@ -997,6 +997,8 @@ ldap_match_call_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gu
           lcr.req_frame=0;
           lcr.rep_frame=pinfo->fd->num;
           break;
+        default:
+          return NULL;
       }
       lcrp=(ldap_call_response_t *)g_hash_table_lookup(ldap_info->matched, &lcr);
 
@@ -1030,7 +1032,7 @@ ldap_match_call_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gu
         }
         /* if we cant reuse the old one, grab a new chunk */
         if(!lcrp){
-          lcrp=se_new(ldap_call_response_t);
+          lcrp=se_new0(ldap_call_response_t);
         }
         lcrp->messageId=messageId;
         lcrp->req_frame=pinfo->fd->num;
@@ -3837,7 +3839,7 @@ static void dissect_PasswordPolicyResponseValue_PDU(tvbuff_t *tvb _U_, packet_in
 
 
 /*--- End of included file: packet-ldap-fn.c ---*/
-#line 878 "../../asn1/ldap/packet-ldap-template.c"
+#line 880 "../../asn1/ldap/packet-ldap-template.c"
 
 static void
 dissect_ldap_payload(tvbuff_t *tvb, packet_info *pinfo,
@@ -5772,7 +5774,7 @@ void proto_register_ldap(void) {
         NULL, HFILL }},
 
 /*--- End of included file: packet-ldap-hfarr.c ---*/
-#line 2232 "../../asn1/ldap/packet-ldap-template.c"
+#line 2234 "../../asn1/ldap/packet-ldap-template.c"
   };
 
   /* List of subtrees */
@@ -5847,7 +5849,7 @@ void proto_register_ldap(void) {
     &ett_ldap_T_warning,
 
 /*--- End of included file: packet-ldap-ettarr.c ---*/
-#line 2245 "../../asn1/ldap/packet-ldap-template.c"
+#line 2247 "../../asn1/ldap/packet-ldap-template.c"
   };
   /* UAT for header fields */
   static uat_field_t custom_attribute_types_uat_fields[] = {
@@ -6004,7 +6006,7 @@ proto_reg_handoff_ldap(void)
 
 
 /*--- End of included file: packet-ldap-dis-tab.c ---*/
-#line 2385 "../../asn1/ldap/packet-ldap-template.c"
+#line 2387 "../../asn1/ldap/packet-ldap-template.c"
 
 
 }
diff --git a/epan/dissectors/packet-rtps.c b/epan/dissectors/packet-rtps.c
index f4e8a1a..3950e8c 100644
--- a/epan/dissectors/packet-rtps.c
+++ b/epan/dissectors/packet-rtps.c
@@ -2505,6 +2505,11 @@ static gint rtps_util_add_typecode(proto_tree *tree,
         dim_max = NEXT_guint32(tvb, offset, little_endian);
         offset += 4;
 
+        if (dim_max > MAX_ARRAY_DIMENSION) {
+            /* We don't have a tree item to add expert info to... */
+            dim_max = MAX_ARRAY_DIMENSION;
+        }
+
         for (i = 0; i < MAX_ARRAY_DIMENSION; ++i) size[i] = 0;
         for (i = 0; i < dim_max; ++i) {
           size[i] = NEXT_guint32(tvb, offset, little_endian);
diff --git a/epan/dissectors/packet-rtps2.c b/epan/dissectors/packet-rtps2.c
index 3732e5f..ad942ef 100644
--- a/epan/dissectors/packet-rtps2.c
+++ b/epan/dissectors/packet-rtps2.c
@@ -2820,6 +2820,11 @@ static gint rtps_util_add_typecode(proto_tree *tree,
         dim_max = NEXT_guint32(tvb, offset, little_endian);
         offset += 4;
 
+        if (dim_max > MAX_ARRAY_DIMENSION) {
+            /* We don't have a tree item to add expert info to... */
+            dim_max = MAX_ARRAY_DIMENSION;
+        }
+
         for (i = 0; i < MAX_ARRAY_DIMENSION; ++i) size[i] = 0;
         for (i = 0; i < dim_max; ++i) {
           size[i] = NEXT_guint32(tvb, offset, little_endian);
-- 
1.7.10.4

